# Heroes Battle - Итоговый проект дисциплины "Алгоритмы и структуры данных"

## Реализованные алгоритмы

### GeneratePreset (Генерация армии компьютера) - **Жадный алгоритм**
Сортировка шаблонов юнитов по коэффициенту `(атака + здоровье)/стоимость` в убывающем порядке. Последовательное добавление юнитов с учетом ограничений: max 11 юнитов/тип, ≤1500 очков, случайное размещение на поле 3×21.

**Алгоритмическая сложность**: **O(T*N)**, где T=4 (типы юнитов), N=max юнитов
- Сортировка: O(T log T) = O(1)
- Генерация координат: O(W*H) = O(63)
- Основной цикл: O(T*N)
- **Итог**: O(T*N)

### SimulateBattle (Симуляция боя) - **Очередь с пересчетом**
По раундам: сбор живых юнитов → сортировка по атаке убывание → чередование ходов с вызовом `unit.getProgram().attack()` → логирование → удаление погибших из очереди.

**Алгоритмическая сложность**: **O(N² log N)**, где N=общее кол-во юнитов
- Раундов: O(N)
- Сбор + сортировка: O(N log N)
- Ходы: O(N)
- **Итог**: O(N² log N)

### SuitableForAttackUnitsFinder (Отбор целей для атаки) - **Линейный проход**
Для каждого ряда проверка видимости юнитов: левая армия (не закрыт слева), правая армия (не закрыт справа). Граничные случаи: null/empty ряды.

**Алгоритмическая сложность**: **O(R*C) = O(N)**, где R=3 (ряды), C=юнитов/ряд, N=общее кол-во
- Проход по рядам: O(R)
- Проход по юнитам: O(C)
- HashSet: O(C)
- **Итог**: O(R*C) = O(N)

### 4. UnitTargetPathFinder (Поиск кратчайшиего пути) - **Алгоритм дейкстры с 8-направлениями**
Поиск кратчайшего пути на сетке 27×21 с диагональным движением. Препятствия — живые юниты (кроме attacker/target). PriorityQueue + восстановление пути через parent.

**Алгоритмическая сложность**: **O(WxH log(WxH))**, где W=27, H=21
- Инициализация: O(W*H)
- Dijkstra: O(V log V), V=W*H=567
- Восстановление пути: O(длина пути)
- **Итог**: O(567 log 567), формально O(W*H log(W * H))

## Сборка и запуск
**Сгенерированный JAR находится в папке**: `build/libs/heroes_battle-1.0-SNAPSHOT.jar`

